# Блок 2: Python
## Задание 1: Изоморфизмы

def is_isomorphic(s: str, t: str) -> bool:
    # Если длины строк разные, они автоматически не изоморфны
    if len(s) != len(t):
        return False
    # Отображение: символ из s → символ из t
    s_to_t = {}
    # Отображение: символ из t → символ из s
    t_to_s = {}
    for c1, c2 in zip(s, t):
        # Если уже встречали c1, проверяем, соответствует ли он тому же c2
        if c1 in s_to_t:
            if s_to_t[c1] != c2:
                return False
        else:
            s_to_t[c1] = c2
        # Если c1 новый, но c2 уже используется другим символом
        if c2 in t_to_s:
            if t_to_s[c2] != c1:
                return False
        else:
            t_to_s[c2] = c1
    return True
# Временная сложность: O(n), где n = len(s) = len(t). Мы проходим по строкам ровно один раз, а операции со словарями (вставка и проверка) в среднем выполняются за O(1).
# Пространственная сложность: O(k), где k — число разных символов в строках. В худшем случае будет O(n), но при ограниченном алфавите это O(1).

## Задание 2: Натуральная последовательность
def missing_number(nums: list[int]) -> int:
    # Определяем, каким должно быть n.
    # Так как одно число пропущено, n — это длина массива + 1
    n = len(nums) + 1
    # Ожидаемая сумма чисел от 1 до n по формуле: n * (n + 1) / 2
    expected_sum = n * (n + 1) // 2
    # Фактическая сумма чисел в массиве
    actual_sum = sum(nums)
    # Разница и есть наше число
    return expected_sum - actual_sum
# Временная сложность: O(n). Мы один раз проходим по массиву при вычислении sum(nums).
# Пространственная сложность: O(1). Используются только несколько переменных, дополнительной структуры данных не создаётся.

## Задание 3: Факторизация
def prime_factors(n):
    factors = []
    d = 2
    # Если n делится на d, добавляем d в список множителей и делим n на d
    while d * d <= n:
        while n % d == 0:
            factors.append(d)
            n //= d
        d += 1
    if n > 1:
        factors.append(n)
    return factors
# Временная сложность: O(sqrt{n}). Мы перебираем делители от 2 до sqrt{n}, а внутренний цикл лишь уменьшает n, не увеличивая порядок.
# Пространственная сложность: O(log(n)) в среднем. В списке factors будет столько элементов, сколько простых множителей, а их количество пропорционально логарифму n.
